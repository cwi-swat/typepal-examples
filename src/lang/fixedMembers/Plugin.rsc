module lang::mtl::ide::Plugin

import ParseTree;
import util::IDE;
import IO;
import ValueIO;


import analysis::typepal::TypePal;

import lang::mtl::core::Syntax;
import lang::mtl::core::checker::MtlChecker;
import lang::mtl::core::generator::Generator;

import util::Reflective;
import lang::manifest::IO;

data MtlManifest 
 = mtlManifest(
      list[str] Source = ["src"],
      list[str] Libraries = ["lib"],
      str Target = "generated",
      str DockerImage = "xlinqreg.azurecr.io/openitems-maverick-develop:latest"
    );        
 
private loc configFile(loc file) =  project(file) + "META-INF" + "RASCAL.MF"; 

private loc project(loc file) {
   assert file.scheme == "project";
   return |project:///|[authority = file.authority];
}


PathConfig getDefaultPathConfig() = pathConfig(srcs = [], libs = []);

PathConfig config(loc file) {
   assert file.scheme == "project";

   p = project(file);
   cfgFile = configFile(file);
   mf = readManifest(#MtlManifest, cfgFile); 
   
   cfg = getDefaultPathConfig();
   
   cfg.srcs += [ p + s | s <- mf.Source];
   cfg.libs += [ p + l | l <- mf.Libraries];
   if (/^\|/ := mf.Target) {
      cfg.target = readTextValueString(#loc, mf.Target);
   }
   else {
      cfg.target = p + mf.Target;
   }
   cfg.dockerImage = mf.DockerImage;
   
   return cfg;
}

data TypePalSummary(
    map[loc, AType] types = (),        // maps locations in the tree to control types
    rel[loc from, loc to] useDef = {}, // relation frome each use to its definition
    set[Message] messages = {}        // messages generated by checker
) = \module();

TypePalSummary makeSummary(loc root, TModel model)  {
    return \module(
        types=getFacts(model), 
        useDef=getUseDef(model), 
        messages={*getMessages(model)}
    );
}

str getModuleName(start[MtlModule] t) = "<m.moduleName>"
	when t has top && MtlModule m := t.top;

str getModuleName(start[MaverickModule] t) = "<m.moduleName>"
	when t has top && MaverickModule m := t.top;
	
	
default str getModuleName(Tree t) = "";

TypePalSummary makeMtlSummary(Tree t, PathConfig pcfg) 
    = makeSummary((t@\loc).top, coreTModelFromTree(t, getModuleName(t), pcfg, true));
    
TypePalSummary makeMaverickSummary(Tree t, PathConfig pcfg) 
    = makeSummary((t@\loc).top, maverickTModelFromTree(t, getModuleName(t), pcfg, true));

Tree checkFixedMembers(Tree input)
    = check(makeMtlSummary, input);    

 

Tree check(TypePalSummary (Tree, PathConfig) calcSummary, Tree input) {
  println("Checking: <input@\loc>"); 
  pcfg = config(input@\loc);
  summary = calcSummary(input, pcfg);
  types = summary.types;
  
  return input[@messages=summary.messages]
              [@hyperlinks=summary.useDef]
              [@docs=(l:"<prettyAType(types[l])>" | l <- types)]
         ;
} 


loc frameworkJar = |plugin://mtl.ide/lib/mtl-framework.jar|;
void copyFrameworkIfOutdated(loc prj) {
    if (exists(frameworkJar)) {
        target = prj + "lib/mtl-framework.jar";
        if (lastModified(target) < lastModified(frameworkJar)) {
            println("Copying framework to project lib folder: <target>");
            copyFile(frameworkJar, target);
        }
    }
}

Contribution commonSyntaxProperties 
    = syntaxProperties(
        fences = {<"{","}">,<"(",")">}, 
        lineComment = "//", 
        blockComment = <"/*","*","*/">
    );


void registerFixedMembers() {
    registerLanguage("FixedMembers", "fm", parseMtlModule);
    registerContributions("MTL", {
        commonSyntaxProperties,
        treeProperties(hasQuickFixes = false),
        annotator(checkFixedMembers)
    });
    
}

void main() {
	registerFixedMembers();
}
